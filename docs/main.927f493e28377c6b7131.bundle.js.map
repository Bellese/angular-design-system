{"version":3,"file":"main.927f493e28377c6b7131.bundle.js","sources":["webpack:///./src/app/services/modal.service.ts"],"sourcesContent":["import {\r\n    Injectable,\r\n    Injector,\r\n    Inject,\r\n    ComponentFactoryResolver,\r\n    EmbeddedViewRef,\r\n    ApplicationRef,\r\n    EventEmitter,\r\n    Output,\r\n    TemplateRef\r\n} from '@angular/core';\r\n\r\nimport {\r\n    DOCUMENT\r\n} from '@angular/common';\r\n\r\n@Injectable()\r\n\r\nexport class ModalService {\r\n\r\n    @Output() modalDestroyed = new EventEmitter<any>();\r\n\r\n    constructor(\r\n        private componentFactoryResolver: ComponentFactoryResolver,\r\n        private appRef: ApplicationRef,\r\n        private injector: Injector,\r\n        private resolver: ComponentFactoryResolver,\r\n        @Inject(DOCUMENT) private doc: any\r\n    ) {\r\n\r\n    }\r\n\r\n    modalCount = 0;\r\n    scrollBarWidth = (window.innerWidth - document.documentElement.clientWidth);\r\n\r\n    prepModalSettings() {\r\n        this.modalCount++;\r\n\r\n        // Must use clientheight and innerheight because mac hides scrollbar automatically so we cant base it off width\r\n        if (document.body.clientHeight > window.innerHeight && this.modalCount === 1) {\r\n\r\n            // Stop background from scrolling\r\n            document.getElementsByTagName('body')[0].style.overflowY = 'hidden';\r\n\r\n            // keep page from bouncing when removing overflow\r\n            const bodyRightMargin = document.getElementsByTagName('body')[0].style.marginRight;\r\n\r\n            // Either there will be a margin tied to body or default is 8px, sccrollbar grabbed by variable\r\n            const margin = bodyRightMargin ? parseInt(bodyRightMargin) + this.scrollBarWidth + 'px' : (this.scrollBarWidth + 8) + 'px';\r\n\r\n            document.getElementsByTagName('body')[0].style.marginRight = margin;\r\n        }\r\n\r\n        // add ariahidden to the modal before another is implemented\r\n        if (this.modalCount > 1) {\r\n            document.getElementById('modalImplementation' + (this.modalCount - 1)).classList.add('modal-aria-hidden');\r\n        }\r\n\r\n        // Keep background from reading 508\r\n        const hideModal = document.getElementsByClassName('modal-aria-hidden');\r\n\r\n        for (let x = 0; x < hideModal.length; x++) {\r\n            hideModal[x].setAttribute('aria-hidden', 'true');\r\n        }\r\n    }\r\n\r\n    removeModalSettings(id) {\r\n        this.modalCount--;\r\n\r\n        // Must use clientheight and innerheight because mac hides scrollbar automatically so we cant base it off width\r\n        if (document.body.clientHeight > window.innerHeight && this.modalCount === 0) {\r\n\r\n            // Allow background to scroll again\r\n            document.getElementsByTagName('body')[0].style.overflowY = 'auto';\r\n\r\n            // keep page from bouncing when removing overflow\r\n            const bodyRightMargin = document.getElementsByTagName('body')[0].style.marginRight;\r\n\r\n            // Either there will be a margin tied to body or default is 8px, sccrollbar is 16px\r\n            const margin =\r\n            bodyRightMargin ? ((parseInt(bodyRightMargin) - this.scrollBarWidth) * 2) / 2 + 'px' : (this.scrollBarWidth + 8) + 'px';\r\n\r\n            document.getElementsByTagName('body')[0].style.marginRight = margin;\r\n        }\r\n\r\n        // add ariahidden to the modal before another is implemented\r\n        if (this.modalCount > 0) {\r\n            document.getElementById('modalImplementation' + (this.modalCount)).setAttribute('aria-hidden', 'false');\r\n        }\r\n\r\n        if (this.modalCount === 0) {\r\n            // Allow 508 to read background again\r\n            const hideModal = document.getElementsByClassName('modal-aria-hidden');\r\n\r\n            for (let x = 0; x < hideModal.length; x++) {\r\n                hideModal[x].setAttribute('aria-hidden', 'false');\r\n            }\r\n        }\r\n\r\n        // Set focus back to button\r\n        setTimeout(() => {\r\n            if (document.getElementById(id)) {\r\n                document.getElementById(id).focus();\r\n            }\r\n        }, 250);\r\n    }\r\n\r\n    appendComponentToBody(component: any, id: any, title: any, data: any, firstFocus) {\r\n        // first create and append a div to hook the modal onto\r\n        if (!document.getElementById('unique-modal-host')) {\r\n            const modalHost = document.createElement('div');\r\n            modalHost.setAttribute('id', 'unique-modal-host');\r\n            document.body.appendChild(modalHost);\r\n        }\r\n\r\n        this.prepModalSettings();\r\n\r\n        // Create a component reference from the component \r\n        const componentRef = this.componentFactoryResolver\r\n            .resolveComponentFactory(component)\r\n            .create(this.injector, this.resolveContentProj(component));\r\n\r\n        // Attach component to the appRef so that it's inside the ng component tree\r\n        this.appRef.attachView(componentRef.hostView);\r\n\r\n        // Get DOM element from component\r\n        const domElem = (componentRef.hostView as EmbeddedViewRef<any>)\r\n            .rootNodes[0] as HTMLElement;\r\n\r\n        // Append DOM element to the div id of modal-host\r\n        document.getElementById('unique-modal-host').appendChild(domElem);\r\n\r\n        // Send Title Inputs to any Modal Body\r\n        (<any>componentRef\r\n            .instance)\r\n            .modalTitle = title;\r\n\r\n        // Send a unique identifier for modals\r\n        (<any>componentRef\r\n            .instance)\r\n            .modalCount = this.modalCount;\r\n\r\n        // Send Data Inputs to any Modal Body\r\n        (<any>componentRef\r\n            .instance)\r\n            .modalData = data;\r\n\r\n        // Focuses on first clickable button that is not the X\r\n        setTimeout(() => {\r\n            if (!firstFocus) {\r\n                firstFocus = 'cancelButton' + this.modalCount;\r\n            }\r\n            document.getElementById(firstFocus).focus();\r\n        }, 0);\r\n\r\n        // Listen for close button to be pushed\r\n        (<any>componentRef\r\n            .instance)\r\n            .closeModal\r\n            .subscribe(x => {\r\n                this.appRef.detachView(componentRef.hostView);\r\n                componentRef.destroy();\r\n\r\n                this.removeModalSettings(id);\r\n            });\r\n    }\r\n\r\n    resolveContentProj(comp) {\r\n\r\n        if (comp) {\r\n            if (typeof comp === 'string') {\r\n                const element = this.doc.createTextNode(comp);\r\n                return [[element]];\r\n            }\r\n\r\n            if (comp instanceof TemplateRef) {\r\n                const viewRef = comp.createEmbeddedView(null);\r\n                return [viewRef.rootNodes];\r\n            }\r\n\r\n            const factory = this.resolver.resolveComponentFactory(comp);\r\n            const componentRef = factory.create(this.injector);\r\n\r\n            return [[componentRef.location.nativeElement]];\r\n        }\r\n    }\r\n}\r\n"],"mappings":"AAkBA","sourceRoot":""}