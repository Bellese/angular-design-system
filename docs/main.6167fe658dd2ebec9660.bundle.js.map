{"version":3,"file":"main.6167fe658dd2ebec9660.bundle.js","sources":["webpack:///./src/app/services/modal.service.ts"],"sourcesContent":["import {\n    Injectable,\n    Injector,\n    Inject,\n    ComponentFactoryResolver,\n    EmbeddedViewRef,\n    ApplicationRef,\n    EventEmitter,\n    Output,\n    TemplateRef\n} from '@angular/core';\n\nimport {\n    DOCUMENT\n} from '@angular/common';\n\n@Injectable()\n\nexport class ModalService {\n\n    @Output() modalDestroyed = new EventEmitter<any>();\n\n    constructor(\n        private componentFactoryResolver: ComponentFactoryResolver,\n        private appRef: ApplicationRef,\n        private injector: Injector,\n        private resolver: ComponentFactoryResolver,\n        @Inject(DOCUMENT) private doc: any\n    ) {\n\n    }\n\n    modalCount = 0;\n    scrollBarWidth = (window.innerWidth - document.documentElement.clientWidth);\n\n    prepModalSettings() {\n        this.modalCount++;\n\n        // Must use clientheight and innerheight because mac hides scrollbar automatically so we cant base it off width\n        if (document.body.clientHeight > window.innerHeight && this.modalCount === 1) {\n\n            // Stop background from scrolling\n            document.getElementsByTagName('body')[0].style.overflowY = 'hidden';\n\n            // keep page from bouncing when removing overflow\n            const bodyRightMargin = document.getElementsByTagName('body')[0].style.marginRight;\n\n            // Either there will be a margin tied to body or default is 8px, sccrollbar grabbed by variable\n            const margin = bodyRightMargin ? parseInt(bodyRightMargin) + this.scrollBarWidth + 'px' : (this.scrollBarWidth + 8) + 'px';\n\n            document.getElementsByTagName('body')[0].style.marginRight = margin;\n        }\n\n        // add ariahidden to the modal before another is implemented\n        if (this.modalCount > 1) {\n            document.getElementById('modalImplementation' + (this.modalCount - 1)).classList.add('modal-aria-hidden');\n        }\n\n        // Keep background from reading 508\n        const hideModal = document.getElementsByClassName('modal-aria-hidden');\n\n        for (let x = 0; x < hideModal.length; x++) {\n            hideModal[x].setAttribute('aria-hidden', 'true');\n        }\n    }\n\n    removeModalSettings(id) {\n        this.modalCount--;\n\n        // Must use clientheight and innerheight because mac hides scrollbar automatically so we cant base it off width\n        if (document.body.clientHeight > window.innerHeight && this.modalCount === 0) {\n\n            // Allow background to scroll again\n            document.getElementsByTagName('body')[0].style.overflowY = 'auto';\n\n            // keep page from bouncing when removing overflow\n            const bodyRightMargin = document.getElementsByTagName('body')[0].style.marginRight;\n\n            // Either there will be a margin tied to body or default is 8px, sccrollbar is 16px\n            const margin =\n            bodyRightMargin ? ((parseInt(bodyRightMargin) - this.scrollBarWidth) * 2) / 2 + 'px' : (this.scrollBarWidth + 8) + 'px';\n\n            document.getElementsByTagName('body')[0].style.marginRight = margin;\n        }\n\n        // add ariahidden to the modal before another is implemented\n        if (this.modalCount > 0) {\n            document.getElementById('modalImplementation' + (this.modalCount)).setAttribute('aria-hidden', 'false');\n        }\n\n        if (this.modalCount === 0) {\n            // Allow 508 to read background again\n            const hideModal = document.getElementsByClassName('modal-aria-hidden');\n\n            for (let x = 0; x < hideModal.length; x++) {\n                hideModal[x].setAttribute('aria-hidden', 'false');\n            }\n        }\n\n        // Set focus back to button\n        setTimeout(() => {\n            if (document.getElementById(id)) {\n                document.getElementById(id).focus();\n            }\n        }, 250);\n    }\n\n    appendComponentToBody(component: any, id: any, title: any, data: any, firstFocus) {\n        // first create and append a div to hook the modal onto\n        if (!document.getElementById('unique-modal-host')) {\n            const modalHost = document.createElement('div');\n            modalHost.setAttribute('id', 'unique-modal-host');\n            document.body.appendChild(modalHost);\n        }\n\n        this.prepModalSettings();\n\n        // Create a component reference from the component \n        const componentRef = this.componentFactoryResolver\n            .resolveComponentFactory(component)\n            .create(this.injector, this.resolveContentProj(component));\n\n        // Attach component to the appRef so that it's inside the ng component tree\n        this.appRef.attachView(componentRef.hostView);\n\n        // Get DOM element from component\n        const domElem = (componentRef.hostView as EmbeddedViewRef<any>)\n            .rootNodes[0] as HTMLElement;\n\n        // Append DOM element to the div id of modal-host\n        document.getElementById('unique-modal-host').appendChild(domElem);\n\n        // Send Title Inputs to any Modal Body\n        (<any>componentRef\n            .instance)\n            .modalTitle = title;\n\n        // Send a unique identifier for modals\n        (<any>componentRef\n            .instance)\n            .modalCount = this.modalCount;\n\n        // Send Data Inputs to any Modal Body\n        (<any>componentRef\n            .instance)\n            .modalData = data;\n\n        // Focuses on first clickable button that is not the X\n        setTimeout(() => {\n            if (!firstFocus) {\n                firstFocus = 'cancelButton' + this.modalCount;\n            }\n            document.getElementById(firstFocus).focus();\n        }, 0);\n\n        // Listen for close button to be pushed\n        (<any>componentRef\n            .instance)\n            .closeModal\n            .subscribe(x => {\n                this.appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n\n                this.removeModalSettings(id);\n            });\n    }\n\n    resolveContentProj(comp) {\n\n        if (comp) {\n            if (typeof comp === 'string') {\n                const element = this.doc.createTextNode(comp);\n                return [[element]];\n            }\n\n            if (comp instanceof TemplateRef) {\n                const viewRef = comp.createEmbeddedView(null);\n                return [viewRef.rootNodes];\n            }\n\n            const factory = this.resolver.resolveComponentFactory(comp);\n            const componentRef = factory.create(this.injector);\n\n            return [[componentRef.location.nativeElement]];\n        }\n    }\n}\n"],"mappings":"AAkBA","sourceRoot":""}